{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Trabalho de Compiladores 1 \u2013 Equipe 12","text":"<p>Bem-vindo \u00e0 documenta\u00e7\u00e3o do projeto desenvolvido na disciplina Compiladores 1, ministrada pelo professor S\u00e9rgio Ant\u00f4nio Andrade de Freitas, no curso de Engenharia de Software da Universidade de Bras\u00edlia (UnB).</p>"},{"location":"#objetivo-do-projeto","title":"\ud83c\udfaf Objetivo do Projeto","text":"<p>Construir um compilador educacional que traduz um subconjunto da linguagem C++ para um formato intermedi\u00e1rio e, posteriormente, para JavaScript.</p> <p>O projeto ser\u00e1 desenvolvido de forma incremental, acompanhando as fases de um compilador:</p> <ol> <li>An\u00e1lise l\u00e9xica</li> <li>An\u00e1lise sint\u00e1tica</li> <li>An\u00e1lise sem\u00e2ntica</li> <li>Gera\u00e7\u00e3o de c\u00f3digo intermedi\u00e1rio</li> <li>Otimiza\u00e7\u00e3o</li> <li>Gera\u00e7\u00e3o de c\u00f3digo final</li> </ol>"},{"location":"#equipe","title":"\ud83d\udc65 Equipe","text":"<ul> <li>Ant\u00f4nio J\u00fanior</li> <li>Heyttor Augusto</li> <li>Jo\u00e3o Pedro Sampaio</li> <li>Lucas Heler</li> <li>Maciel J\u00fanior</li> </ul>"},{"location":"#estrutura-da-documentacao","title":"\ud83d\udcc2 Estrutura da Documenta\u00e7\u00e3o","text":"<ul> <li>Escopo da Linguagem</li> <li>Metodologia</li> <li>Defini\u00e7\u00e3o das sprints</li> <li>Estrutura do compilador</li> <li>Gram\u00e1tica Formal (CGF)</li> <li>Documento de Refer\u00eancia</li> <li>Refer\u00eancia de tradu\u00e7\u00e3o</li> </ul>"},{"location":"#historico-do-projeto","title":"\ud83d\udccc Hist\u00f3rico do Projeto","text":"<p>O desenvolvimento segue a abordagem PBL (Project Based Learning) e est\u00e1 organizado em sprints, com pontos de controle e apresenta\u00e7\u00f5es ao longo do semestre.</p>"},{"location":"definicao_sprints/","title":"Defini\u00e7\u00e3o das sprints","text":""},{"location":"definicao_sprints/#planejamento-de-sprints","title":"Planejamento de Sprints","text":"<p>Adotaremos um fluxo inspirado em Scrum: em cada Sprint Planning definimos metas e tarefas para a pr\u00f3xima sprint; fazemos acompanhamentos r\u00e1pidos para destravar impedimentos e encerramos cada sprint com a sprint review para mostrar o que foi conclu\u00eddo e o que \u00e9 esperado para a pr\u00f3xima sprint.</p>"},{"location":"definicao_sprints/#sprint-1","title":"Sprint 1","text":"<p>Inicio: 27/08 Fim: 09/09</p> <p>objetivos</p> <ul> <li>Definir se seria feito um compilador ou intepretador (todos)</li> <li>Definir as linguagens para o compilador (todos)</li> <li>Definir tamanho e quantas sprints o trabalho ter\u00e1 (todos)</li> <li>Documenta\u00e7\u00e3o do escopo (Maciel)</li> </ul>"},{"location":"definicao_sprints/#sprint-2","title":"Sprint 2","text":"<p>inicio: 10/09 Fim: 01/10</p> <p>Objetivos</p> <ul> <li>Adi\u00e7\u00e3o do readme (heyttor)</li> <li>implementa\u00e7\u00e3o da ast minima (maciel)</li> <li>implementa\u00e7\u00e3o do parser (heyttor e ranni)</li> <li>implementa\u00e7\u00e3o do scarnner (antonio e jo\u00e3o)</li> </ul>"},{"location":"definicao_sprints/#sprint-3","title":"Sprint 3","text":"<p>inicio: 02/10 fim: 15/10</p> <p>Objetivos</p> <ul> <li>Dar os primeiros passos na an\u00e1lise sem\u00e2ntica (tipo de vari\u00e1veis, escopos). (maciel)</li> <li>Evoluir o analisador sint\u00e1tico com novas produ\u00e7\u00f5es gramaticais. (Heyttor)</li> <li>Analisador sem\u00e2ntico inicial identificando erros b\u00e1sicos (vari\u00e1veis n\u00e3o declaradas, tipos simples). (Antonio)</li> <li>Estender as regras gramaticais no Bison, cobrindo as principais constru\u00e7\u00f5es da linguagem. (Ranni)</li> <li>Implementar verifica\u00e7\u00e3o de tipos e de escopo simples (reportar erros se algo estiver fora das regras) (Jo\u00e3o)</li> </ul> <p>## Sprint 4</p> <p>inicio: 16/10   fim: 12/11</p> <p>Objetivos</p> <ul> <li>Testes do scanner (tokens e literais) (Antonio)</li> <li>Finalizar express\u00f5es regulares no Flex (tokens principais) (Antonio)</li> <li>Criar infraestrutura de testes e documenta\u00e7\u00e3o - Golden tests e make test (Antonio)</li> <li>Preced\u00eancia e associatividade (express\u00f5es) (Maciel)</li> <li>Resolver conflito shift/reduce (Maciel)</li> <li>Literais e identificadores na AST - AST \u2014 Constru\u00e7\u00e3o da \u00c1rvore de Sintaxe Abstrata (Maciel)</li> <li>Main + testes b\u00e1sicos de AST (Maciel)</li> <li>Blocos {} e lista de statements (Heyttor)</li> <li>Statements de express\u00e3o (Heyttor)</li> <li>Integrar controle de fluxo e blocos ao parser (Heyttor)</li> <li>Criar n\u00f3s de controle de fluxo na AST (If, While, For, Return, Block) (Heyttor)</li> <li>If / If-Else (dangling else) (Heyttor)</li> <li>While e For (Heyttor)</li> <li>n\u00f3 chamada de fun\u00e7\u00e3o AST (Heyttor e maciel)</li> <li>Tabela de s\u00edmbolos: escopos (Ranni)</li> <li>Criar tabela de s\u00edmbolos e gest\u00e3o de escopos ( Ranni)</li> <li>Adicionar declara\u00e7\u00e3o de vari\u00e1veis (var) (Ranni)</li> <li>Atribui\u00e7\u00e3o IDENT = Expr (Ranni)</li> <li>Implementar atribui\u00e7\u00e3o IDENT = Expr - Strings (escapes e mem\u00f3ria) (Ranni)</li> <li>Consolidar literais string e ND_STRING (Ranni)</li> <li>Tipagem b\u00e1sica  (Jo\u00e3o)</li> <li>Implementar infer\u00eancia e checagem de tipos (Jo\u00e3o)</li> <li>Erros sem\u00e2nticos: uso sem declara\u00e7\u00e3o (Jo\u00e3o)</li> <li>Detectar identificadores n\u00e3o declarados (Jo\u00e3o)</li> <li>Documenta\u00e7\u00e3o das sprints e metodologia (Heyttor)</li> <li>Documenta\u00e7\u00e3o da estrutura </li> </ul> <p>## Sprint 6</p> <p>Inicio da sprint 13/11   Fim da sprint 28/11</p> <p>Objetivos</p> <ul> <li>Constru\u00e7\u00e3o da logica de golden teste make test (maciel)</li> <li>Suporte a declara\u00e7\u00f5es de tipos primitivos (maciel)</li> <li>Implementa\u00e7\u00e3o da sfun\u00e7\u00f5es de retorno (maciel)</li> <li>Suporte a fun\u00e7\u00f5es na gera\u00e7\u00e3o IR (Heyttor)</li> <li>Criar testes IR (Ranni)</li> <li>Documenta\u00e7\u00e3o da IR (Antonio)</li> <li>Implementa\u00e7\u00e3o das compara\u00e7\u00f5es em IR e na gera\u00e7\u00e3o do codigo final (Heyttor)</li> <li>Implementa\u00e7\u00e3o das literias e mov em IR e na gera\u00e7\u00e3o do codigo final (Maciel)</li> <li>Implementa\u00e7\u00e3o da Aritmetica(+,-,* e / ) em IR e na gera\u00e7\u00e3o do codigo final (Maciel)</li> <li>Implementa\u00e7\u00e3o do controle de fluxo (labels e branches ) (Ranni)</li> <li>Implementa\u00e7\u00e3o das Strings em IR e na gera\u00e7\u00e3o do codigo final (Maciel,Antonio e Jo\u00e3o)</li> <li>Implementa\u00e7\u00e3o dos testes de compara\u00e7\u00e3o na gera\u00e7\u00e3o do codigo final (Heyttor e Marciel)</li> </ul>"},{"location":"escopo/","title":"Escopo da Linguagem (Projeto de Compilador)","text":"<p>Este documento define o subconjunto da linguagem C++ que ser\u00e1 incialmente suportado pelo compilador desenvolvido na disciplina Compiladores 1. O escopo foi planejado para ser vi\u00e1vel dentro do semestre e suficiente para todas as fases do compilador.</p> <p>Este escopo poder\u00e1 ser revisado e expandido ao longo da disciplina, conforme a evolu\u00e7\u00e3o do projeto e a capacidade da equipe em implementar novas features.</p>"},{"location":"escopo/#tipos-primitivos","title":"Tipos Primitivos","text":"Tipo Descri\u00e7\u00e3o Exemplos <code>int</code> N\u00fameros inteiros <code>10</code>, <code>42</code> <code>float</code> N\u00fameros de ponto flutuante <code>3.14</code>, <code>0.5</code> <code>bool</code> Valores l\u00f3gicos <code>true</code>, <code>false</code> <code>string</code> Cadeias de caracteres (texto) <code>\"texto\"</code>, <code>\"abc\"</code> <p>Observa\u00e7\u00e3o sobre <code>string</code></p> <p>No C++ real, cadeias de caracteres s\u00e3o representadas pela classe <code>std::string</code>, definida na biblioteca padr\u00e3o (STL). Isso implica em uso de namespaces (<code>std::</code>), inclus\u00e3o de headers (<code>&lt;string&gt;</code>) e toda a infraestrutura de classes da linguagem.</p> <p>Para simplifica\u00e7\u00e3o neste projeto, consideraremos <code>string</code> como um tipo primitivo, no mesmo n\u00edvel de <code>int</code>, <code>float</code> e <code>bool</code>. Assim, o compilador pode lidar com vari\u00e1veis e literais de string sem exigir suporte a namespaces, classes ou bibliotecas externas.</p> <p>Caso seja decidido expandir o escopo futuramente, poderemos ajustar a gram\u00e1tica para reconhecer <code>std::string</code>, mas isso traria maior complexidade (namespaces e classes), que est\u00e1 fora do escopo m\u00ednimo inicial.</p>"},{"location":"escopo/#identificadores-literais-e-comentarios","title":"Identificadores, Literais e Coment\u00e1rios","text":"Categoria Descri\u00e7\u00e3o Exemplos Identificadores Devem come\u00e7ar com letra ou <code>_</code>, seguidos de letras, d\u00edgitos ou <code>_</code> <code>x</code>, <code>contador</code>, <code>soma1</code> Literais Valores concretos escritos no c\u00f3digo <code>10</code>, <code>3.14</code>, <code>\"abc\"</code>, <code>true</code> Coment\u00e1rios Anota\u00e7\u00f5es ignoradas pelo compilador <code>// coment\u00e1rio</code> <code>/* coment\u00e1rio */</code>"},{"location":"escopo/#operadores","title":"Operadores","text":"Categoria Operadores Exemplos Aritm\u00e9ticos <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> <code>x + y</code>, <code>a * b</code> Relacionais <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> <code>x == y</code>, <code>a &lt; b</code> L\u00f3gicos <code>&amp;&amp;</code>, <code>||</code>, <code>!</code> <code>(x &gt; 0 &amp;&amp; y &gt; 0)</code> Atribui\u00e7\u00e3o <code>=</code> <code>x = 10</code>"},{"location":"escopo/#declaracoes-de-variaveis","title":"Declara\u00e7\u00f5es de Vari\u00e1veis","text":""},{"location":"escopo/#declaracao-sem-inicializacao","title":"Declara\u00e7\u00e3o Sem Inicializa\u00e7\u00e3o","text":"<pre><code>int x;\nfloat y;\nbool ativo;\nstring nome;\n</code></pre>"},{"location":"escopo/#declaracao-com-inicializacao","title":"Declara\u00e7\u00e3o Com Inicializa\u00e7\u00e3o","text":"<pre><code>int x = 5;\nbool ativo = true;\nstring nome = \"teste\";\n</code></pre>"},{"location":"escopo/#atribuicoes-e-expressoes","title":"Atribui\u00e7\u00f5es e Express\u00f5es","text":"<pre><code>x = 10;\ny = x + 2.5;\nativo = (x &gt; y);\nnome = \"teste\";\n</code></pre>"},{"location":"escopo/#estruturas-de-controle-de-fluxo","title":"Estruturas de controle de fluxo","text":""},{"location":"escopo/#ifelse","title":"If/Else","text":"<pre><code>if (x &gt; 0) {\n    y = y + 1;\n} else {\n    y = 0;\n}\n</code></pre>"},{"location":"escopo/#while","title":"While","text":"<pre><code>while (y &lt; 10) {\n    y = y + 1;\n}\n</code></pre>"},{"location":"escopo/#for","title":"For","text":"<pre><code>for (int i = 0; i &lt; 10; i = i + 1) {\n    x = x + i;\n}\n</code></pre>"},{"location":"escopo/#funcoes","title":"Fun\u00e7\u00f5es","text":""},{"location":"escopo/#definicao","title":"Defini\u00e7\u00e3o","text":"<pre><code>int soma(int a, int b) {\n    return a + b;\n}\n</code></pre>"},{"location":"escopo/#chamada","title":"Chamada","text":"<pre><code>int r = soma(2, 3);\n</code></pre>"},{"location":"escopo/#palavras-chave-reservadas","title":"Palavras-chave reservadas","text":"<ul> <li><code>int</code></li> <li><code>float</code></li> <li><code>bool</code></li> <li><code>string</code></li> <li><code>if</code></li> <li><code>else</code></li> <li><code>while</code></li> <li><code>for</code></li> <li><code>true</code></li> <li><code>false</code></li> <li><code>return</code></li> <li><code>print</code></li> <li><code>read</code></li> </ul>"},{"location":"escopo/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Vers\u00e3o Data Autor(es) Descri\u00e7\u00e3o 1.0 13/09/2025 Ant\u00f4nio J\u00fanior, Heyttor Augusto, Jo\u00e3o Pedro Sampaio, Lucas Heler, Maciel J\u00fanior Cria\u00e7\u00e3o inicial do documento de escopo"},{"location":"estrutura/","title":"Estrutura do Projeto de Compilador","text":""},{"location":"estrutura/#include","title":"\ud83d\udcc1 Include/","text":""},{"location":"estrutura/#include-cabecalhos-h-com-definicoes-de-estruturas-e-interfaces","title":"Include/ - Cabe\u00e7alhos (.h) com defini\u00e7\u00f5es de estruturas e interfaces","text":"<ul> <li>AST, tabela de s\u00edmbolos, analisadores sint\u00e1tico/sem\u00e2ntico</li> </ul>"},{"location":"estrutura/#asth","title":"ast.h","text":"<ul> <li>Fun\u00e7\u00e3o: Header principal da AST que inclui todos os outros headers relacionados</li> <li>Depende de: <code>ast_base.h</code>, <code>ast_expr.h</code>, <code>ast_printer.h</code>, <code>ast_free.h</code>, <code>symbol_table.h</code></li> <li>Fun\u00e7\u00e3o: Facilita o include de toda a estrutura de AST em um \u00fanico arquivo</li> </ul>"},{"location":"estrutura/#ast_baseh","title":"ast_base.h","text":"<ul> <li>Fun\u00e7\u00e3o: Define a estrutura fundamental da \u00c1rvore Sint\u00e1tica Abstrata (AST)</li> <li>Componentes:</li> <li>Enums: <code>TypeTag</code> (tipos), <code>NodeKind</code> (tipos de n\u00f3s), <code>BinOp</code> (opera\u00e7\u00f5es bin\u00e1rias), <code>UnOp</code> (opera\u00e7\u00f5es un\u00e1rias)</li> <li>Struct <code>Node</code>: Uni\u00e3o que representa todos os tipos poss\u00edveis de n\u00f3s da AST</li> <li>Fun\u00e7\u00f5es utilit\u00e1rias: <code>xmalloc()</code>, <code>xstrdup()</code>, <code>new_node()</code>, <code>ast_copy()</code></li> </ul>"},{"location":"estrutura/#ast_exprh","title":"ast_expr.h","text":"<ul> <li>Fun\u00e7\u00e3o: Declara fun\u00e7\u00f5es construtoras para cada tipo de n\u00f3 da AST</li> <li>Fun\u00e7\u00f5es: Construtores para literais, express\u00f5es, declara\u00e7\u00f5es, estruturas de controle, fun\u00e7\u00f5es</li> </ul>"},{"location":"estrutura/#ast_freeh","title":"ast_free.h","text":"<ul> <li>Fun\u00e7\u00e3o: Interface para libera\u00e7\u00e3o de mem\u00f3ria da AST</li> <li>Fun\u00e7\u00e3o: <code>ast_free()</code> - libera recursivamente toda a \u00e1rvore</li> </ul>"},{"location":"estrutura/#ast_printerh","title":"ast_printer.h","text":"<ul> <li>Fun\u00e7\u00e3o: Interface para impress\u00e3o da AST</li> <li>Fun\u00e7\u00f5es: <code>ast_print()</code> (formato compacto), <code>ast_print_pretty()</code> (formato indentado)</li> </ul>"},{"location":"estrutura/#symbol_tableh","title":"symbol_table.h","text":"<ul> <li>Fun\u00e7\u00e3o: Define a estrutura da tabela de s\u00edmbolos com escopos</li> <li>Componentes:</li> <li>Struct <code>Symbol</code>: Representa um s\u00edmbolo (nome, tipo, valor)</li> <li>Struct <code>SymbolTable</code>: Tabela hash com encadeamento e suporte a escopos aninhados</li> <li>Opera\u00e7\u00f5es: inser\u00e7\u00e3o, busca, atualiza\u00e7\u00e3o, remo\u00e7\u00e3o (com vers\u00f5es recursivas para escopos)</li> </ul>"},{"location":"estrutura/#semantic_analyzerh","title":"semantic_analyzer.h","text":"<ul> <li>Fun\u00e7\u00e3o: Interface do analisador sem\u00e2ntico</li> <li>Fun\u00e7\u00f5es: <code>check_semantics()</code> (executa an\u00e1lise), <code>semantics_ok()</code> (verifica se n\u00e3o h\u00e1 erros)</li> </ul>"},{"location":"estrutura/#syntax_analyzerh","title":"syntax_analyzer.h","text":"<ul> <li>Fun\u00e7\u00e3o: Interface do analisador sint\u00e1tico</li> <li>Struct: <code>SyntaxResult</code> - padroniza o resultado da an\u00e1lise sint\u00e1tica</li> <li>Fun\u00e7\u00e3o: <code>syntax_parse_path()</code> - analisa arquivo ou stdin</li> </ul>"},{"location":"estrutura/#ir_builderh","title":"ir_builder.h","text":"<ul> <li>Fun\u00e7\u00e3o: Fornece a API para gerar o Intermediate Representation (IR) a partir da \u00c1rvore Sint\u00e1tica Abstrata (AST). -fun\u00e7\u00f5es: <code>void irb_emit_stmt(IrFunc *f, Node *stmt)</code> -  Gera IR para um statement, <code>int  irb_emit_expr(IrFunc *f, Node *expr)</code> - Gera IR para uma express\u00e3o e retorna o tempor\u00e1rio tN com o resultado , </li> </ul>"},{"location":"estrutura/#ir_printerh","title":"ir_printer.h","text":"<ul> <li>Fun\u00e7\u00e3o: Fornece utilit\u00e1rios para visualiza\u00e7\u00e3o do IR \u2014 impress\u00e3o textual, dump para debug e (opcionalmente) gera\u00e7\u00e3o de formatos leg\u00edveis por ferramentas.</li> <li>Fun\u00e7\u00f5es: <code>void ir_print_program(const IrProgram *p)</code> - Imprime cada instru\u00e7\u00e3o do IR</li> </ul>"},{"location":"estrutura/#irh","title":"ir.h","text":"<ul> <li>Fun\u00e7\u00e3o: Define as estruturas e tipos que representam o Intermediate Representation (IR) do compilador.</li> <li>Fun\u00e7\u00f5es: <code>ir_program_new()</code> - Cria uma estrutura vazia de programa IR,<code>ir_program_free(p)</code>- Libera toda a mem\u00f3ria associada ao programa IR,</li> </ul>"},{"location":"estrutura/#src","title":"\ud83d\udcc1 src/","text":""},{"location":"estrutura/#src-implementacao-c-de-toda-a-logica-do-compilador","title":"src/ - Implementa\u00e7\u00e3o (.c) de toda a l\u00f3gica do compilador","text":"<ul> <li>Construtores de AST, an\u00e1lise l\u00e9xica/sint\u00e1tica/sem\u00e2ntica, gerenciamento de mem\u00f3ria</li> </ul>"},{"location":"estrutura/#ast_basec","title":"ast_base.c","text":"<ul> <li>Fun\u00e7\u00e3o: Implementa fun\u00e7\u00f5es b\u00e1sicas da AST</li> <li>Fun\u00e7\u00f5es Principais:</li> <li><code>xmalloc()</code>, <code>xstrdup()</code> - aloca\u00e7\u00e3o segura de mem\u00f3ria</li> <li><code>new_node()</code> - cria novo n\u00f3</li> <li><code>ast_copy()</code> - c\u00f3pia profunda completa da AST</li> </ul>"},{"location":"estrutura/#ast_exprc","title":"ast_expr.c","text":"<ul> <li>Fun\u00e7\u00e3o: Implementa construtores de n\u00f3s da AST</li> <li>Cobertura: Todos os tipos de n\u00f3s definidos em <code>ast_base.h</code></li> <li>Destaque: <code>ast_block_add_stmt()</code> - gerencia array din\u00e2mico de statements</li> </ul>"},{"location":"estrutura/#ast_freec","title":"ast_free.c","text":"<ul> <li>Fun\u00e7\u00e3o: Libera\u00e7\u00e3o recursiva de mem\u00f3ria da AST</li> <li>Implementa\u00e7\u00e3o: Switch que trata cada tipo de n\u00f3 especificamente</li> </ul>"},{"location":"estrutura/#ast_printerc","title":"ast_printer.c","text":"<ul> <li>Fun\u00e7\u00e3o: Implementa impress\u00e3o da AST em dois formatos</li> <li>Fun\u00e7\u00f5es:</li> <li><code>ast_print()</code> - formato linear (para m\u00e1quina)</li> <li><code>ast_print_pretty()</code> - formato indentado (para humanos)</li> <li>Helpers: Conversores de enums para strings</li> </ul>"},{"location":"estrutura/#parsery","title":"parser.y","text":"<ul> <li>Fun\u00e7\u00e3o: Gram\u00e1tica Bison do compilador</li> <li>Caracter\u00edsticas:</li> <li>Gram\u00e1tica LALR(1) completa da linguagem</li> <li>Suporte a express\u00f5es, declara\u00e7\u00f5es, estruturas de controle, fun\u00e7\u00f5es</li> <li>Preced\u00eancia e associatividade de operadores</li> <li>Recupera\u00e7\u00e3o de erros sint\u00e1ticos</li> <li>Constr\u00f3i AST durante o parsing</li> </ul>"},{"location":"estrutura/#scannerl","title":"scanner.l","text":"<ul> <li>Fun\u00e7\u00e3o: Analisador l\u00e9xico Flex</li> <li>Tokeniza\u00e7\u00e3o: Reconhece literais, identificadores, operadores, palavras-chave</li> <li>Caracter\u00edsticas:</li> <li>Suporte a coment\u00e1rios de linha e multilinha</li> <li>Processamento de strings com sequ\u00eancias de escape</li> <li>Contagem de linha e coluna</li> <li>Recupera\u00e7\u00e3o de erros l\u00e9xicos</li> </ul>"},{"location":"estrutura/#semantic_analyzerc","title":"semantic_analyzer.c","text":"<ul> <li>Fun\u00e7\u00e3o: Implementa an\u00e1lise sem\u00e2ntica completa</li> <li>Funcionalidades:</li> <li>Sistema de escopos aninhados</li> <li>Verifica\u00e7\u00e3o de tipos em express\u00f5es e atribui\u00e7\u00f5es</li> <li>Valida\u00e7\u00e3o de declara\u00e7\u00f5es e uso de vari\u00e1veis</li> <li>Verifica\u00e7\u00e3o de chamadas de fun\u00e7\u00e3o (aridade e tipos)</li> <li>Controle de retorno em fun\u00e7\u00f5es</li> <li>Registro e valida\u00e7\u00e3o de assinaturas de fun\u00e7\u00f5es</li> </ul>"},{"location":"estrutura/#symbol_tablec","title":"symbol_table.c","text":"<ul> <li>Fun\u00e7\u00e3o: Implementa tabela de s\u00edmbolos com hash table</li> <li>Caracter\u00edsticas:</li> <li>Tabela hash com encadeamento</li> <li>Suporte a escopos aninhados via campo <code>parent</code></li> <li>Opera\u00e7\u00f5es de inser\u00e7\u00e3o, busca, atualiza\u00e7\u00e3o e remo\u00e7\u00e3o</li> <li>Fun\u00e7\u00f5es recursivas para busca em escopos pai</li> </ul>"},{"location":"estrutura/#syntax_analyzerc","title":"syntax_analyzer.c","text":"<ul> <li>Fun\u00e7\u00e3o: Driver do analisador sint\u00e1tico</li> <li>Fun\u00e7\u00e3o: <code>syntax_parse_path()</code> - coordena parsing de arquivo/stdin</li> </ul>"},{"location":"estrutura/#ir_builderc","title":"ir_builder.c","text":"<ul> <li>Fun\u00e7\u00e3o: Construtor do IR</li> </ul>"},{"location":"estrutura/#irc","title":"IR.c","text":"<ul> <li>Fun\u00e7\u00e3o gerador do codigo intermediario</li> </ul>"},{"location":"estrutura/#codegen_jsc","title":"codegen_js.c","text":"<ul> <li>Fun\u00e7\u00e3o gerador final do codigo em js</li> </ul>"},{"location":"estrutura/#srcdrivers","title":"\ud83d\udcc1 src/drivers/","text":""},{"location":"estrutura/#srcdrivers-programas-de-teste-independentes","title":"src/drivers/ - Programas de teste independentes","text":"<ul> <li>Testes espec\u00edficos do lexer, parser e pipeline completo</li> </ul>"},{"location":"estrutura/#lexer_driverc","title":"lexer_driver.c","text":"<ul> <li>Fun\u00e7\u00e3o: Teste independente do analisador l\u00e9xico</li> <li>Funcionalidade: Tokeniza entrada e mostra tokens reconhecidos</li> </ul>"},{"location":"estrutura/#syntax_driverc","title":"syntax_driver.c","text":"<ul> <li>Fun\u00e7\u00e3o: Teste do analisador sint\u00e1tico</li> <li>Funcionalidade: Parsing completo com impress\u00e3o da AST resultante</li> </ul>"},{"location":"estrutura/#semantic_driverc","title":"semantic_driver.c","text":"<ul> <li>Fun\u00e7\u00e3o: Teste do pipeline completo (l\u00e9xico + sint\u00e1tico + sem\u00e2ntico)</li> <li>Funcionalidade: Executa todas as fases e reporta erros</li> </ul>"},{"location":"estrutura/#arquitetura-geral","title":"Arquitetura Geral","text":""},{"location":"estrutura/#fluxo-de-compilacao","title":"Fluxo de Compila\u00e7\u00e3o:","text":"<ol> <li>An\u00e1lise L\u00e9xica (scanner.l) \u2192 Tokens</li> <li>An\u00e1lise Sint\u00e1tica (parser.y) \u2192 AST</li> <li>An\u00e1lise Sem\u00e2ntica (semantic_analyzer.c) \u2192 AST Validada</li> <li>Tabela de S\u00edmbolos (symbol_table.c) \u2192 Escopos e Tipos</li> </ol>"},{"location":"estrutura/#caracteristicas-da-linguagem","title":"Caracter\u00edsticas da Linguagem:","text":"<ul> <li>Tipos: int, float, bool, string, void</li> <li>Estruturas: if/else, while, for, functions, return</li> <li>Express\u00f5es: Aritm\u00e9ticas, relacionais, l\u00f3gicas</li> <li>Escopos: Blocos aninhados com tabela de s\u00edmbolos hier\u00e1rquica</li> </ul>"},{"location":"estrutura/#design-patterns","title":"Design Patterns:","text":"<ul> <li>Visitor Pattern: Para an\u00e1lise sem\u00e2ntica e impress\u00e3o da AST</li> <li>Factory Pattern: Construtores de n\u00f3s em <code>ast_expr.c</code></li> <li>Composite Pattern: Estrutura de \u00e1rvore da AST</li> </ul> Vers\u00e3o Data Autor(es) Descri\u00e7\u00e3o 1.0 10/11/2025 akaeboshi Documenta\u00e7\u00e3o completa da arquitetura do compilador incluindo estrutura de pastas, Fun\u00e7\u00e3o dos arquivos e fluxo de compila\u00e7\u00e3o"},{"location":"gramatica/","title":"Gram\u00e1tica Formal (CFG) do Subconjunto de C++","text":"<p>Este documento descreve a gram\u00e1tica livre de contexto (CFG) correspondente ao subconjunto da linguagem C++ definido no Escopo da Linguagem. Ela servir\u00e1 como base para o desenvolvimento do analisador sint\u00e1tico utilizando Bison.</p>"},{"location":"gramatica/#simbolo-inicial","title":"S\u00edmbolo inicial","text":"<pre><code>Program \u2192 DeclOrStmtList\n</code></pre> <pre><code>DeclOrStmtList \u2192 (DeclOrStmt)*\nDeclOrStmt     \u2192 Decl ';' | Stmt\n</code></pre>"},{"location":"gramatica/#declaracoes","title":"Declara\u00e7\u00f5es","text":""},{"location":"gramatica/#tipos-suportados","title":"Tipos suportados:","text":"<pre><code>Type \u2192 'int' | 'float' | 'bool' | 'string'\n</code></pre>"},{"location":"gramatica/#declaracoes_1","title":"Declara\u00e7\u00f5es:","text":"<pre><code>Decl \u2192 Type IDENTIFIER ( '=' Expr )?\n</code></pre>"},{"location":"gramatica/#exemplos-validos","title":"Exemplos v\u00e1lidos:","text":"<pre><code>int x;\nfloat y = 3.14;\nbool ativo = true;\nstring nome;\n</code></pre>"},{"location":"gramatica/#comandos","title":"Comandos","text":""},{"location":"gramatica/#blocos-e-lista-de-comandos","title":"Blocos e lista de comandos:","text":"<pre><code>Block   \u2192 '{' StmtList? '}'\nStmtList\u2192 (Stmt)+\n</code></pre>"},{"location":"gramatica/#comandos-possiveis","title":"Comandos poss\u00edveis:","text":"<pre><code>Stmt \u2192 Assign ';'\n     | If\n     | While\n     | For\n     | Expr ';'\n</code></pre>"},{"location":"gramatica/#atribuicoes","title":"Atribui\u00e7\u00f5es:","text":"<pre><code>Assign \u2192 IDENTIFIER '=' Expr\n</code></pre>"},{"location":"gramatica/#exemplos-validos_1","title":"Exemplos v\u00e1lidos:","text":"<pre><code>x = 10;\ny = x + 2.5;\nativo = (x &gt; y);\nnome = \"teste\";\n</code></pre>"},{"location":"gramatica/#ifelse","title":"If/Else:","text":"<pre><code>If \u2192 'if' '(' Expr ')' Stmt ('else' Stmt)?\n</code></pre>"},{"location":"gramatica/#exemplo-valido","title":"Exemplo v\u00e1lido:","text":"<pre><code>if (x &gt; 0) {\n    y = y + 1;\n} else {\n    y = 0;\n}\n</code></pre>"},{"location":"gramatica/#while","title":"While:","text":"<pre><code>While \u2192 'while' '(' Expr ')' Stmt\n</code></pre>"},{"location":"gramatica/#exemplo-valido_1","title":"Exemplo v\u00e1lido:","text":"<pre><code>while (y &lt; 10) {\n    y = y + 1;\n}\n</code></pre>"},{"location":"gramatica/#for","title":"For:","text":"<pre><code>For     \u2192 'for' '(' ForInit? ';' ForCond? ';' ForStep? ')' Stmt\nForInit \u2192 Decl | Assign\nForCond \u2192 Expr\nForStep \u2192 Assign\n</code></pre> <p>Exemplo v\u00e1lido: <pre><code>for (int i = 0; i &lt; 10; i = i + 1) {\n    soma = soma + i;\n}\n</code></pre></p>"},{"location":"gramatica/#precedencia-de-operadores","title":"Preced\u00eancia de Operadores","text":"<ol> <li><code>()</code> \u2014 Par\u00eanteses</li> <li><code>!</code>, <code>-</code> \u2014 Un\u00e1rios</li> <li><code>*</code>, <code>/</code> \u2014 Multiplicativos</li> <li><code>+</code>, <code>-</code> \u2014 Aditivos</li> <li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> \u2014 Relacionais</li> <li><code>==</code>, <code>!=</code> \u2014 Igualdade</li> <li><code>&amp;&amp;</code> \u2014 L\u00f3gico AND</li> <li><code>||</code> \u2014 L\u00f3gico OR</li> </ol>"},{"location":"gramatica/#lexico-terminais","title":"L\u00e9xico (terminais)","text":"<ul> <li>Identificadores: <code>IDENTIFIER</code></li> <li>Literais:</li> <li><code>INT_LIT</code> \u2192 n\u00fameros inteiros (ex.: <code>10</code>, <code>42</code>)</li> <li><code>FLOAT_LIT</code> \u2192 n\u00fameros de ponto flutuante (ex.: <code>3.14</code>, <code>0.5</code>)</li> <li><code>STRING_LIT</code> \u2192 cadeias de caracteres entre aspas (ex.: <code>\"abc\"</code>)</li> <li><code>BOOL_LIT</code> \u2192 <code>true</code> | <code>false</code></li> <li>Palavras-chave: <code>int</code>, <code>float</code>, <code>bool</code>, <code>string</code>, <code>if</code>, <code>else</code>, <code>while</code>, <code>for</code></li> <li>S\u00edmbolos/operadores:   <code>= + - * / == != &lt; &gt; &lt;= &gt;= &amp;&amp; || ! ( ) { } ; ,</code></li> </ul>"},{"location":"gramatica/#historico-de-versoes","title":"Hist\u00f3rico de Vers\u00f5es","text":"Vers\u00e3o Data Autor(es) Descri\u00e7\u00e3o 1.0 14/09/2025 Ant\u00f4nio J\u00fanior, Heyttor Augusto, Jo\u00e3o Pedro Sampaio, Lucas Heler, Maciel J\u00fanior Primeira vers\u00e3o da gram\u00e1tica formal"},{"location":"ir_to_js/","title":"Refer\u00eancia de Tradu\u00e7\u00e3o: IR (Intermediate Representation) para JavaScript","text":"<p>Contexto: Antes de implementar o backend, esta documenta\u00e7\u00e3o descreve como cada instru\u00e7\u00e3o da nossa Representa\u00e7\u00e3o Intermedi\u00e1ria (IR) \u00e9 traduzida para o c\u00f3digo JavaScript equivalente.</p> <p>Objetivo: Servir como documenta\u00e7\u00e3o de refer\u00eancia completa para a tradu\u00e7\u00e3o de IR para JavaScript.</p>"},{"location":"ir_to_js/#1-definicao-do-formato-de-funcoes-js","title":"1. Defini\u00e7\u00e3o do Formato de Fun\u00e7\u00f5es JS","text":"<p>Aqui definiremos o formato de wrapper para as fun\u00e7\u00f5es geradas em JavaScript, que encapsular\u00e3o o c\u00f3digo traduzido das instru\u00e7\u00f5es IR.</p> <ul> <li>Conven\u00e7\u00e3o de Nomenclatura: Como as fun\u00e7\u00f5es IR ser\u00e3o nomeadas no JS?<ul> <li>Exemplo: A fun\u00e7\u00e3o IR <code>func@main</code> se torna <code>function main(...) { ... }</code></li> </ul> </li> <li>Assinatura da Fun\u00e7\u00e3o (Par\u00e2metros e Retorno): Como os par\u00e2metros e o valor de retorno ser\u00e3o manipulados?</li> <li>Estrutura Base: <pre><code>// Formato B\u00e1sico de Fun\u00e7\u00e3o JS\nfunction [NOME_FUNCAO]([PARAMETROS]) {\n    // [C\u00d3DIGO TRADUZIDO DAS INSTRU\u00c7\u00d5ES IR]\n}\n</code></pre></li> </ul>"},{"location":"ir_to_js/#2-regras-para-temporarios-e-variaveis","title":"2. Regras para Tempor\u00e1rios e Vari\u00e1veis","text":"<p>Esta se\u00e7\u00e3o define como as vari\u00e1veis (locais, globais) e os registradores tempor\u00e1rios da IR s\u00e3o representados em JavaScript.</p> <ul> <li>Vari\u00e1veis Locais:<ul> <li>Mapeamento: Devem ser declaradas com <code>let</code> ou <code>const</code> no escopo da fun\u00e7\u00e3o JS.</li> <li>Exemplo: <code>var x</code> (IR) \u2192 <code>let x;</code> (JS)</li> </ul> </li> <li>Registradores Tempor\u00e1rios (<code>t0</code>, <code>t1</code>, ...):<ul> <li>Mapeamento: Tamb\u00e9m declarados como vari\u00e1veis locais no JS.</li> <li>Conven\u00e7\u00e3o: Use um prefixo para evitar conflito de nomes, ex: <code>t0</code> (IR) \u2192 <code>let temp0;</code> (JS)</li> </ul> </li> </ul>"},{"location":"ir_to_js/#3-mapeamento-de-instrucoes-ir-javascript","title":"3. Mapeamento de Instru\u00e7\u00f5es IR \u2192 JavaScript","text":"<p>Esta \u00e9 a se\u00e7\u00e3o central que mapeia cada instru\u00e7\u00e3o da IR para seu equivalente em JavaScript.</p> Categoria Instru\u00e7\u00e3o IR Sem\u00e2ntica C\u00f3digo JavaScript Equivalente Observa\u00e7\u00f5es Aritm\u00e9tica <code>add t1, t2, t3</code> $t_1 = t_2 + t_3$ <code>let t1 = t2 + t3;</code> <code>sub t1, t2, t3</code> $t_1 = t_2 - t_3$ <code>let t1 = t2 - t3;</code> <code>mul t1, t2, t3</code> $t_1 = t_2 * t_3$ <code>let t1 = t2 * t3;</code> <code>div t1, t2, t3</code> $t_1 = t_2 / t_3$ <code>let t1 = t2 / t3;</code> Se a IR usa divis\u00e3o inteira, considere <code>Math.trunc(t2 / t3)</code>. <code>mod t1, t2, t3</code> $t_1 = t_2 \\bmod t_3$ <code>let t1 = t2 % t3;</code> <code>neg t1, t2</code> $t_1 = -t_2$ <code>let t1 = -t2;</code> L\u00f3gica Bitwise <code>and t1, t2, t3</code> $t_1 = t_2 \\text{ \\&amp; } t_3$ <code>let t1 = t2 &amp; t3;</code> <code>or t1, t2, t3</code> $t_1 = t_2 \\text{ \\textbar } t_3$ <code>let t1 = t2 \\| t3;</code> <code>xor t1, t2, t3</code> $t_1 = t_2 \\text{ \\^{} } t_3$ <code>let t1 = t2 ^ t3;</code> <code>shl t1, t2, t3</code> Shift Left: $t_1 = t_2 \\ll t_3$ <code>let t1 = t2 &lt;&lt; t3;</code> Compara\u00e7\u00e3o <code>cmp_eq t1, t2, t3</code> $t_1 = (t_2 = t_3)$ <code>let t1 = t2 === t3;</code> Importante: Usar igualdade estrita (<code>===</code>). <code>cmp_lt t1, t2, t3</code> $t_1 = (t_2 &lt; t_3)$ <code>let t1 = t2 &lt; t3;</code> <code>cmp_ge t1, t2, t3</code> $t_1 = (t_2 \\geq t_3)$ <code>let t1 = t2 &gt;= t3;</code> <code>cmp_neq t1, t2, t3</code> $t_1 = (t_2 \\neq t_3)$ <code>let t1 = t2 !== t3;</code> Mem\u00f3ria <code>load t1, @var</code> $t_1 = var$ <code>let t1 = var;</code> <code>@var</code> \u00e9 uma vari\u00e1vel no escopo JS. <code>store t1, @var</code> $var = t_1$ <code>var = t1;</code> <code>load_arr t1, @arr, t2</code> $t_1 = arr[t_2]$ <code>let t1 = arr[t2];</code> Assume que <code>@arr</code> \u00e9 um objeto Array ou similar. <code>store_arr t1, @arr, t2</code> $arr[t_2] = t_1$ <code>arr[t2] = t1;</code> Chamada de Fun\u00e7\u00e3o <code>call t1, @func, t2, t3</code> $t_1 = func(t_2, t_3)$ <code>let t1 = func(t2, t3);</code> Presume que a fun\u00e7\u00e3o <code>@func</code> foi traduzida para <code>func</code>. <code>ret t1</code> Retorna $t_1$ <code>return t1;</code> ---"},{"location":"ir_to_js/#4-traducao-de-fluxo-de-controle","title":"4. Tradu\u00e7\u00e3o de Fluxo de Controle","text":"<p>Aqui definiremos como as estruturas de controle IR (labels, desvios) s\u00e3o transformadas em estruturas de controle JS (loops, condicionais, <code>goto</code> simulado).</p> <ul> <li>Labels (Blocos B\u00e1sicos):<ul> <li>Abordagem: Simula\u00e7\u00e3o de GOTO usando labels de bloco JS, switch-case ou reestrutura\u00e7\u00e3o para <code>while(true)</code> com <code>break</code>.</li> <li>Exemplo (Simula\u00e7\u00e3o com Switch): Cada label IR (<code>L0</code>, <code>L1</code>) se torna um case dentro de um loop.</li> </ul> </li> <li>Branch Incondicional (<code>br L1</code>):<ul> <li>Tradu\u00e7\u00e3o: <code>continue L1_label;</code> (se usando labels de bloco JS) ou atualiza\u00e7\u00e3o de uma vari\u00e1vel de controle de switch.</li> </ul> </li> <li>Branch Condicional (<code>brfalse t1, L1</code>):<ul> <li>Tradu\u00e7\u00e3o: <code>if (!t1) { goto L1; }</code> (usando a t\u00e9cnica de GOTO simulado).</li> </ul> </li> <li>Fun\u00e7\u00e3o de Retorno (<code>ret t0</code>):<ul> <li>Tradu\u00e7\u00e3o: <code>return t0;</code></li> </ul> </li> </ul>"},{"location":"ir_to_js/#5-exemplos-completos","title":"5. Exemplos Completos","text":"<p>Exemplos da tradu\u00e7\u00e3o dos c\u00f3digos de IR para JS</p>"},{"location":"ir_to_js/#exemplo-51-funcao-simples-soma","title":"Exemplo 5.1: Fun\u00e7\u00e3o Simples (Soma)","text":"<p>C\u00f3digo IR:</p> <pre><code>func@sum {\n    t0 = add p0, p1\n    ret t0\n}\n</code></pre> <p>C\u00f3digo JavaScript Traduzido:</p> <pre><code>function sum(p0, p1) {\n    let t0 = p0 + p1;\n    return t0;\n}\n</code></pre>"},{"location":"ir_to_js/#exemplo-52-acesso-e-modificacao-de-array-memoria","title":"Exemplo 5.2: Acesso e Modifica\u00e7\u00e3o de Array (Mem\u00f3ria)","text":"<p>C\u00f3digo IR:</p> <pre><code>func@IncrementaPrimeiro(p0) {\n    // p0 \u00e9 o array de entrada\n\n    // t0 = arr[0]\n    t0 = load_arr p0, 0 \n\n    // t1 = t0 + 1\n    t1 = add t0, 1 \n\n    // arr[0] = t1\n    store_arr t1, p0, 0 \n\n    ret t1\n}\n</code></pre> <p>C\u00f3digo JavaScript Traduzido:</p> <pre><code>function IncrementaPrimeiro(p0) {\n    // Declara\u00e7\u00e3o de tempor\u00e1rios\n    let t0;\n    let t1; \n\n    // t0 = arr[0]\n    t0 = p0[0];\n\n    // t1 = t0 + 1\n    t1 = t0 + 1;\n\n    // arr[0] = t1\n    p0[0] = t1;\n\n    return t1;\n}\n</code></pre>"},{"location":"ir_to_js/#exemplo-53-chamada-de-funcao-e-retorno","title":"Exemplo 5.3: Chamada de Fun\u00e7\u00e3o e Retorno","text":"<p>C\u00f3digo IR:</p> <pre><code>func@UsaSoma(p0, p1) {\n    // t0 = sum(p0, p1)\n    t0 = call @sum, p0, p1\n\n    // t1 = t0 * 2\n    t1 = mul t0, 2\n\n    ret t1\n}\n</code></pre> <p>C\u00f3digo JavaScript Traduzido:</p> <pre><code>// A fun\u00e7\u00e3o 'sum' deve ser definida em outro lugar ou no mesmo escopo\nfunction UsaSoma(p0, p1) {\n    // Declara\u00e7\u00e3o de tempor\u00e1rios\n    let t0;\n    let t1;\n\n    // t0 = call @sum, p0, p1\n    t0 = sum(p0, p1);\n\n    // t1 = t0 * 2\n    t1 = t0 * 2;\n\n    return t1;\n}\n</code></pre>"},{"location":"ir_to_js/#exemplo-54-expressao-logica-andor","title":"Exemplo 5.4: Express\u00e3o L\u00f3gica (AND/OR)","text":"<p>C\u00f3digo IR:</p> <pre><code>func@ChecaIntervalo(p0, p1) {\n    // t0 = (p0 &gt; 10)\n    t0 = cmp_gt p0, 10\n\n    // t1 = (p1 &lt; 5)\n    t1 = cmp_lt p1, 5\n\n    // t2 = t0 AND t1\n    t2 = and t0, t1 \n\n    ret t2\n}\n</code></pre> <p>C\u00f3digo JavaScript Traduzido:</p> <pre><code>function ChecaIntervalo(p0, p1) {\n    // Declara\u00e7\u00e3o de tempor\u00e1rios\n    let t0;\n    let t1;\n    let t2;\n\n    // t0 = (p0 &gt; 10)\n    t0 = p0 &gt; 10;\n\n    // t1 = (p1 &lt; 5)\n    t1 = p1 &lt; 5;\n\n    // t2 = t0 AND t1\n    // Nota: Em JS, booleanos s\u00e3o coercidos para 0/1 em opera\u00e7\u00f5es bitwise.\n    // Se a IR trata 'true' como 1 e 'false' como 0:\n    t2 = t0 &amp; t1; \n\n    // Se a IR quer o resultado como booleano JS (true/false):\n    // t2 = t0 &amp;&amp; t1; \n\n    return t2;\n}\n</code></pre>"},{"location":"ir_to_js/#exemplo-55-movimentacao-copia-direta","title":"Exemplo 5.5: Movimenta\u00e7\u00e3o (C\u00f3pia Direta)","text":"<p>C\u00f3digo IR:</p> <pre><code>func@MoveValue(p0) {\n    // t0 = p0 (Copia o valor)\n    t0 = move p0\n\n    // t1 = 5 (Carrega uma constante)\n    t1 = load_const 5 \n\n    // t2 = t0 + t1\n    t2 = add t0, t1\n\n    ret t2\n}\n</code></pre> <p>C\u00f3digo JavaScript Traduzido:</p> <pre><code>function MoveValue(p0) {\n    // Declara\u00e7\u00e3o de tempor\u00e1rios\n    let t0;\n    let t1;\n    let t2;\n\n    // t0 = move p0\n    t0 = p0; \n\n    // t1 = 5\n    t1 = 5; \n\n    // t2 = t0 + t1\n    t2 = t0 + t1;\n\n    return t2;\n}\n</code></pre>"},{"location":"metodologia/","title":"Metodologia","text":""},{"location":"metodologia/#metodologia-escolhida-scrum","title":"Metodologia escolhida (Scrum)","text":"<p>A metodologia Scrum \u00e9 uma estrutura \u00e1gil para o desenvolvimento de produtos complexos, ideal para projetos que exigem flexibilidade, colabora\u00e7\u00e3o e entregas incrementais. Para o desenvolvimento de um compilador de C++ para javascrpt, o Scrum oferece uma abordagem robusta e adapt\u00e1vel, justificando sua escolha por diversas raz\u00f5es-chave.</p>"},{"location":"metodologia/#projeto-complexo-e-incremental","title":"Projeto complexo e incremental","text":"<p>Um compilador, mesmo reduzido, \u00e9 um software de alta complexidade com varias etapas interdependentes.O Scrum permite dividir esse grande problema em partes menores e entreg\u00e1veis, cada uma agregando valor tang\u00edvel,Isso torna o desenvolvimento mais control\u00e1vel, test\u00e1vel e ajust\u00e1vel a cada ciclo.</p>"},{"location":"metodologia/#colaboracao-constante-e-revisao-continua","title":"Colabora\u00e7\u00e3o constante e revis\u00e3o cont\u00ednua","text":"<p>A metodologia incentiva reuni\u00f5es curtas e frequentes (daily scrums) e demonstra\u00e7\u00f5es de progresso (sprint reviews). Isso \u00e9 perfeito para um projeto t\u00e9cnico, pois:</p> <ul> <li> <p>permite feedback r\u00e1pido sobre cada m\u00f3dulo (por exemplo, testes de tradu\u00e7\u00e3o de fun\u00e7\u00f5es ou estruturas de controle),</p> </li> <li> <p>ajuda a alinhar o time sobre decis\u00f5es t\u00e9cnicas e padr\u00f5es de c\u00f3digo,</p> </li> <li> <p>reduz o risco de falhas acumuladas.</p> </li> </ul>"},{"location":"metodologia/#entregas-funcionais-e-testaveis-a-cada-sprint","title":"Entregas funcionais e test\u00e1veis a cada sprint","text":"<p>Essas entregas permitem testes reais e demonstra\u00e7\u00f5es progressivas da evolu\u00e7\u00e3o do compilador.</p>"},{"location":"referencia/","title":"Documento de Refer\u00eancia da Linguagem (Subconjunto C++ \u2192 JavaScript)","text":"<p>Este documento consolida o escopo definido para o compilador e organiza as informa\u00e7\u00f5es necess\u00e1rias para o desenvolvimento: tokens, palavras-chave, operadores e exemplos v\u00e1lidos/ inv\u00e1lidos. Ele servir\u00e1 como refer\u00eancia para toda a equipe.</p>"},{"location":"referencia/#tabela-de-tokens","title":"Tabela de Tokens","text":"Categoria Nome / Token Regex Simplificada Exemplos v\u00e1lidos Identificadores IDENT <code>[a-zA-Z_][a-zA-Z0-9_]*</code> <code>x</code>, <code>contador</code>, <code>_valor1</code> N\u00fameros inteiros INT_LITERAL <code>[0-9]+</code> <code>0</code>, <code>42</code>, <code>1234</code> N\u00fameros float FLOAT_LITERAL <code>[0-9]+\\.[0-9]+</code> <code>3.14</code>, <code>0.5</code>, <code>10.0</code> Booleanos BOOL_LITERAL <code>true|false</code> <code>true</code>, <code>false</code> Strings STRING_LITERAL <code>\"(.*?)\"</code> <code>\"abc\"</code>, <code>\"texto\"</code> Operadores aritm\u00e9ticos PLUS, MINUS, STAR, SLASH <code>\\+</code>, <code>-</code>, <code>\\*</code>, <code>/</code> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> Operadores relacionais EQ, NEQ, LT, GT, LE, GE <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> <code>x == y</code>, <code>a &lt; b</code> Operadores l\u00f3gicos AND, OR <code>&amp;&amp;</code>, <code>\\|\\|</code> <code>x &amp;&amp; y</code>, <code>a || b</code> Atribui\u00e7\u00e3o ASSIGN <code>=</code> <code>x = 10</code> Pontua\u00e7\u00e3o LPAR, RPAR, LBRACE, RBRACE, SEMI, COMMA <code>\\(</code>, <code>\\)</code>, <code>{</code>, <code>}</code>, <code>;</code>, <code>,</code> <code>( ) { } ; ,</code> Coment\u00e1rio linha COMMENT_LINE <code>//.*</code> <code>// exemplo</code> Coment\u00e1rio bloco COMMENT_BLOCK <code>/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/</code> <code>/* exemplo */</code>"},{"location":"referencia/#palavras-chave-reservadas","title":"Palavras-chave Reservadas","text":"<pre><code>int, float, bool, string,\nif, else, while, for,\ntrue, false,\nreturn, print, read\n\n````\n\n **Observa\u00e7\u00e3o**: Identificadores n\u00e3o podem ter o mesmo nome das palavras-chave.\n\n---\n\n##  Preced\u00eancia e Associatividade de Operadores\n\n| N\u00edvel (maior \u2192 menor) | Operadores              | Associatividade |\n|------------------------|-------------------------|-----------------|\n| 1 (maior)             | `()` (par\u00eanteses)      | Esquerda \u2192 Direita |\n| 2                     | `*`, `/`               | Esquerda \u2192 Direita |\n| 3                     | `+`, `-`               | Esquerda \u2192 Direita |\n| 4                     | `&lt;`, `&lt;=`, `&gt;`, `&gt;=`   | Esquerda \u2192 Direita |\n| 5                     | `==`, `!=`             | Esquerda \u2192 Direita |\n| 6                     | `&amp;&amp;`, `||`             | Esquerda \u2192 Direita |\n| 7 (menor)             | `=` (atribui\u00e7\u00e3o)       | Direita \u2192 Esquerda |\n\n---\n\n##  Exemplos M\u00ednimos\n\n### Declara\u00e7\u00f5es de vari\u00e1veis\n```cpp\nint x;\nfloat y = 3.14;\nbool ativo = true;\nstring nome = \"teste\";\n````\n\n### Express\u00f5es e atribui\u00e7\u00f5es\n\n```cpp\nx = 10;\ny = x + 2.5;\nativo = (x &gt; y);\nnome = \"abc\";\n</code></pre>"},{"location":"referencia/#controle-de-fluxo","title":"Controle de fluxo","text":"<pre><code>if (x &gt; 0) {\n    y = y + 1;\n} else {\n    y = 0;\n}\n\nwhile (y &lt; 10) {\n    y = y + 1;\n}\n\nfor (int i = 0; i &lt; 10; i = i + 1) {\n    x = x + i;\n}\n</code></pre>"},{"location":"referencia/#funcoes","title":"Fun\u00e7\u00f5es","text":"<pre><code>int soma(int a, int b) {\n    return a + b;\n}\n\nint r = soma(2, 3);\n</code></pre>"},{"location":"referencia/#exemplos-invalidos-para-testes-negativos","title":"Exemplos Inv\u00e1lidos (para testes negativos)","text":"<pre><code>int 1abc;          // identificador n\u00e3o pode come\u00e7ar com n\u00famero\nfloat x = \"abc\";   // tipo incompat\u00edvel\nbool ativo = 10;   // tipo incompat\u00edvel\nstring nome = abc; // string precisa de aspas\nif x &gt; 0 {         // par\u00eanteses obrigat\u00f3rios na condi\u00e7\u00e3o\n    y = 1;\n}\nint soma(a, b) {   // par\u00e2metros precisam de tipo\n    return a + b;\n}\n</code></pre> Vers\u00e3o Data Autor(es) Descri\u00e7\u00e3o 1.0 24/09/2025 Ant\u00f4nio J\u00fanior, Heyttor Augusto, Jo\u00e3o Pedro Sampaio, Lucas Heler, Maciel J\u00fanior Cria\u00e7\u00e3o inicial do documento de refer\u00eancia"}]}